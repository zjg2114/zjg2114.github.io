(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{249:function(t,s,n){t.exports=n.p+"assets/img/lazy.6f59ccd1.jpg"},297:function(t,s,n){"use strict";n.r(s);var a=n(28),e=Object(a.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"intersectionobserver"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#intersectionobserver"}},[t._v("#")]),t._v(" IntersectionObserver")]),t._v(" "),a("p",[t._v("当后端返回一组没有分页过的庞大数据时,前端如果不作处理,直接丢给浏览渲染的话,会给浏览器造成极大的性能负担,加载时间过长,甚至造成网页未响应")]),t._v(" "),a("p",[t._v("这时候就需要前端按照一定的逻辑做懒加载的处理,所谓懒加载就是数据不会一次性全部加载,当用户滚动页面,数据即将进入视口时才会开始加载代码")]),t._v(" "),a("p",[t._v("思路分析:")]),t._v(" "),a("ol",[a("li",[t._v("将接口的完整数据保存在内存中")]),t._v(" "),a("li",[t._v("给渲染组件绑定的数据设定初始值用于首次渲染(根据一条数据对于视口容器的占比来决定)")]),t._v(" "),a("li",[t._v("对没有进图视口的就近元素监听当用户滚动到被监听的那条数据时,再向绑定的数据中添加指定条数的数据")]),t._v(" "),a("li",[t._v("解除之前元素的绑定,对新的元素绑定,以此循环")])]),t._v(" "),a("p",[t._v("交叉观察器: IntersectionObserver，目标元素与视口产生一个交叉区,可以监听元素进入视口。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" io "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("IntersectionObserver")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("callback"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" option"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// IntersectionObserver是浏览器原生提供的构造函数，接受两个参数：callback是可见性变化时的回调函数，option是配置对象（该参数可选）。")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 构造函数的返回值是一个观察器实例。实例的observe方法可以指定观察哪个 DOM 节点。")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 开始观察")]),t._v("\nio"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("observe")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getElementById")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'example'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 停止观察")]),t._v("\nio"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("unobserve")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("element"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 关闭观察器")]),t._v("\nio"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("disconnect")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("h2",{attrs:{id:"callback-参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#callback-参数"}},[t._v("#")]),t._v(" callback 参数")]),t._v(" "),a("p",[t._v("目标元素的可见性变化时，就会调用观察器的回调函数callback。\ncallback一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" io "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("IntersectionObserver")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("entries")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("entries"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("上面代码中，回调函数采用的是箭头函数的写法。callback函数的参数（entries）是一个数组，包含所有被监听的元素的IntersectionObserverEntry对象;")]),t._v(" "),a("p",[t._v("IntersectionObserverEntry对象提供目标元素的信息，一共有六个属性。\n每个属性的含义如下。")]),t._v(" "),a("ul",[a("li",[t._v("time：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒")]),t._v(" "),a("li",[t._v("target：被观察的目标元素，是一个 DOM 节点对象")]),t._v(" "),a("li",[t._v("rootBounds：根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回null")]),t._v(" "),a("li",[t._v("boundingClientRect：目标元素的矩形区域的信息")]),t._v(" "),a("li",[t._v("intersectionRect：目标元素与视口（或根元素）的交叉区域的信息")]),t._v(" "),a("li",[t._v("intersectionRatio：目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0")])]),t._v(" "),a("h2",{attrs:{id:"option-对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#option-对象"}},[t._v("#")]),t._v(" Option 对象")]),t._v(" "),a("p",[t._v("IntersectionObserver构造函数的第二个参数是一个配置对象。它可以设置以下属性。")]),t._v(" "),a("ul",[a("li",[t._v("threshold 属性\nthreshold属性决定了什么时候触发回调函数。它是一个数组，每个成员都是一个门槛值，默认为[0]，即交叉比例（intersectionRatio）达到0时触发回调函数。")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("IntersectionObserver")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("entries")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* ... */")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" \n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//   用户可以自定义这个数组。比如，[0, 0.5, 1]就表示当目标元素 0%、50%、100% 可见时，会触发回调函数。")]),t._v("\n    threshold"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.25")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.75")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("ul",[a("li",[t._v("root 属性")])]),t._v(" "),a("p",[t._v("IntersectionObserver API 支持容器内滚动。root属性指定目标元素所在的容器节点（即根元素）。")]),t._v(" "),a("ul",[a("li",[t._v("rootMargin 属性")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" opts "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  root"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("querySelector")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'.container'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  rootMargin"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"500px 0px"')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("上面代码中，除了root属性，还有rootMargin属性。后者定义根元素的margin，用来扩展或缩小rootBounds这个矩形的大小，从而影响intersectionRect交叉区域的大小。它使用类似CSS的定义方法")]),t._v(" "),a("p",[t._v("场景：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("当前屏幕最多只能显示3张纵向排列的卡片")])]),t._v(" "),a("li",[a("p",[t._v("默认首次从列表中取前四个数据做渲染")])]),t._v(" "),a("li",[a("p",[t._v("监听第四张卡片进入观察区，那么向数组中再添加4条数据并监听第八张卡片")])]),t._v(" "),a("li",[a("p",[t._v("以此循环，不断地监听和取消监听")]),t._v(" "),a("p",[a("img",{attrs:{src:n(249),alt:"验证证书"}})])])])])}),[],!1,null,null,null);s.default=e.exports}}]);