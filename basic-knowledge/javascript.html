<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>javascript | joe&#39;s blog</title>
    <meta name="description" content="周俊贵个人博客">
    <meta name="generator" content="VuePress 1.4.0">
    <link rel="icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.2a8ad169.css" as="style"><link rel="preload" href="/assets/js/app.aedc5ffe.js" as="script"><link rel="preload" href="/assets/js/2.70898950.js" as="script"><link rel="preload" href="/assets/js/3.b6e4ebb5.js" as="script"><link rel="prefetch" href="/assets/js/10.11dc62f7.js"><link rel="prefetch" href="/assets/js/11.3a894ea9.js"><link rel="prefetch" href="/assets/js/12.0c30f304.js"><link rel="prefetch" href="/assets/js/13.facc7040.js"><link rel="prefetch" href="/assets/js/14.1eb693d5.js"><link rel="prefetch" href="/assets/js/15.15ab7951.js"><link rel="prefetch" href="/assets/js/16.679f5af6.js"><link rel="prefetch" href="/assets/js/17.db7e493a.js"><link rel="prefetch" href="/assets/js/18.b512b508.js"><link rel="prefetch" href="/assets/js/19.f8901854.js"><link rel="prefetch" href="/assets/js/20.2aa8e3a9.js"><link rel="prefetch" href="/assets/js/21.7983abd0.js"><link rel="prefetch" href="/assets/js/22.32896dab.js"><link rel="prefetch" href="/assets/js/23.57865db1.js"><link rel="prefetch" href="/assets/js/24.a57124b2.js"><link rel="prefetch" href="/assets/js/25.eda5ceb8.js"><link rel="prefetch" href="/assets/js/26.df393e3f.js"><link rel="prefetch" href="/assets/js/27.add7c426.js"><link rel="prefetch" href="/assets/js/28.6287cfa5.js"><link rel="prefetch" href="/assets/js/29.2b77468c.js"><link rel="prefetch" href="/assets/js/30.b7a5e4ba.js"><link rel="prefetch" href="/assets/js/31.e5b87034.js"><link rel="prefetch" href="/assets/js/32.f0460536.js"><link rel="prefetch" href="/assets/js/33.b1c0fbe7.js"><link rel="prefetch" href="/assets/js/4.35e1c144.js"><link rel="prefetch" href="/assets/js/5.aa8ff341.js"><link rel="prefetch" href="/assets/js/6.782cbce5.js"><link rel="prefetch" href="/assets/js/7.acde5501.js"><link rel="prefetch" href="/assets/js/8.4f729283.js"><link rel="prefetch" href="/assets/js/9.45446f5c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.2a8ad169.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">joe's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="源码分析" class="dropdown-title"><span class="title">源码分析</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/code-analysis/vue-analysis/reactive/" class="nav-link">
  vue
</a></li><li class="dropdown-item"><!----> <a href="/code-analysis/react-analysis/" class="nav-link">
  react
</a></li></ul></div></div><div class="nav-item"><a href="/basic-knowledge/javascript.html" class="nav-link router-link-exact-active router-link-active">
  基础理论
</a></div><div class="nav-item"><a href="/code/debounce&amp;throttle.html" class="nav-link">
  coding
</a></div><div class="nav-item"><a href="/daily-record/io.html" class="nav-link">
  日常笔记
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="源码分析" class="dropdown-title"><span class="title">源码分析</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/code-analysis/vue-analysis/reactive/" class="nav-link">
  vue
</a></li><li class="dropdown-item"><!----> <a href="/code-analysis/react-analysis/" class="nav-link">
  react
</a></li></ul></div></div><div class="nav-item"><a href="/basic-knowledge/javascript.html" class="nav-link router-link-exact-active router-link-active">
  基础理论
</a></div><div class="nav-item"><a href="/code/debounce&amp;throttle.html" class="nav-link">
  coding
</a></div><div class="nav-item"><a href="/daily-record/io.html" class="nav-link">
  日常笔记
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/basic-knowledge/javascript.html" class="active sidebar-link">javascript</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/basic-knowledge/javascript.html#原型" class="sidebar-link">原型</a></li><li class="sidebar-sub-header"><a href="/basic-knowledge/javascript.html#作用域-闭包" class="sidebar-link">作用域&amp;闭包</a></li><li class="sidebar-sub-header"><a href="/basic-knowledge/javascript.html#js-的单线程" class="sidebar-link">JS 的单线程</a></li></ul></li><li><a href="/basic-knowledge/es2015+.html" class="sidebar-link">es2015</a></li><li><a href="/basic-knowledge/network.html" class="sidebar-link">network</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="javascript"><a href="#javascript" class="header-anchor">#</a> javascript</h1> <h2 id="原型"><a href="#原型" class="header-anchor">#</a> 原型</h2> <p>javascript 在设计继承机制的时候没有选择引入 class 类的概念（es6 引入了 class 关键字，本质还是构造函数的语法糖），主要是依靠 new 后面跟构造函数的方式来生成实例对象的。</p> <p>举个栗子</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Hero</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// this就指向了实例对象</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> timo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hero</span><span class="token punctuation">(</span><span class="token string">&quot;提莫&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>timo<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 提莫</span>
</code></pre></div><h3 id="new-操作符"><a href="#new-操作符" class="header-anchor">#</a> new 操作符</h3> <p>如何实现一个 new 操作符,首先知道 new 做了什么</p> <ol><li>首先创建一个空的对象，空对象的<strong>proto</strong>属性指向构造函数的原型对象,其实就是构造函数的 this 指向实例</li> <li>把上面创建的空对象赋值构造函数内部的 this，用构造函数内部的方法修改空对象</li> <li>如果构造函数返回一个非基本类型的值，则返回这个值，否则上面创建的对象</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// new的简单实现</span>
<span class="token keyword">function</span> <span class="token function">_new</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> <span class="token operator">...</span>arg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>fn<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> ret <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> ret <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token operator">?</span> ret <span class="token operator">:</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>用构造函数生成实例对象，有一个缺点，那就是无法共享属性和方法。</p></div> <h3 id="prototype"><a href="#prototype" class="header-anchor">#</a> prototype</h3> <p>于是 javascript 引入了 protrotype 属性，所有实例对象需要共享的属性和方法，都放在这个构造函数的 prototype 中。举个栗子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Hero</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// this就指向了实例对象</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Hero</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">skill</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">的技能</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> timo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hero</span><span class="token punctuation">(</span><span class="token string">&quot;提莫&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> noc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hero</span><span class="token punctuation">(</span><span class="token string">&quot;魔腾&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
timo<span class="token punctuation">.</span><span class="token function">skill</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 提莫的技能</span>
noc<span class="token punctuation">.</span><span class="token function">skill</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 魔腾的技能</span>
</code></pre></div><p>把 skill 方法放在 hero 的原型对象上后，所有生成的实例都可以共享；当我修改 prototype 的属性时，也会影响所有的实例对象，达到了继承的目的</p> <h3 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链</h3> <p>当调用某种方法或查找某种属性时，首先会在自身调用和查找，如果自身并没有该属性或方法，则会去它的<strong>proto</strong>属性中调用查找，这个<strong>proto</strong>指向了它的构造函数的 prototype，这一寻找过程形成的查找链就是原型链。</p> <p>老规矩上图(百度来的 选了一个比较清楚的)：</p> <p><img src="/assets/img/prototype.9c86c76a.jpg" alt="原型链"></p> <p>这里有两个比较特殊的地方：</p> <ol><li>构造函数 Function 的 prototype 和<strong>proto</strong>都指向 Function.prototype(因为 Function 也是 Function 构造的 ^-^)</li> <li>Object.prototype 最终指向 null，也就是所有的原型链都是以 null 为终点</li></ol> <h3 id="instanceof-constructor"><a href="#instanceof-constructor" class="header-anchor">#</a> instanceof &amp; constructor</h3> <h4 id="constructor"><a href="#constructor" class="header-anchor">#</a> constructor</h4> <p>在 js 中创建的每个函数都会有一个 prototype（原型）对象，这个原型对象上会有一个 constructor 属性，这个属性默认情况下指向构造函数。</p> <p><img src="/assets/img/constructor.aef3f9c1.jpg" alt="constructor"></p> <p>但当我们将构造函数的 prototype 指向一个的新的对象时，constructor 属性就不再指向 Hero。
因为会把构造函数默认的 prototype 被新对象覆盖，那么指向构造函数的 constructor 就不复存在。</p> <p><img src="/assets/img/constructor2.e71e01e8.jpg" alt="constructor"></p> <p>如果我们对 Hero.prototype 重新赋值后希望 constructor 仍指向 Hero 的话，可以手动添加一个 constructor 属性让它指向 Hero</p> <p><img src="/assets/img/constructor4.a2b284ae.jpg" alt="constructor"></p> <p>虽然 constructor 重新指向 Hero，但同时我们也发现 constructor 变成了可枚举属性，constructor 属性默认是不可枚举的，即[[Enumerable]]的值为 false</p> <p><img src="/assets/img/constructor5.9fa001dd.jpg" alt="constructor"></p> <p>没事！困难总比办法多(😏 😏)</p> <div class="language-js extra-class"><pre class="language-js"><code>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token class-name">Hero</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token string">&quot;constructor&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  enumerable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  value<span class="token operator">:</span> Hero<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><img src="/assets/img/constructor6.684af84e.jpg" alt="constructor"></p> <h4 id="instanceof"><a href="#instanceof" class="header-anchor">#</a> instanceof</h4> <p>instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性
instanceof 不仅可以判断实例对象直接的构造函数，而且还能判断原型链上所有的构造函数，上面代码中 Object 在 person 的原型链中，所以返回 true。
可见 Person.prototype 对象被重写并不影响 instanceof 的判断，因为 instanceof 是根据原型链来判断构造函数的，只要对象实例的原型链不发生变化，instanceof 便可以正确判断</p> <h2 id="作用域-闭包"><a href="#作用域-闭包" class="header-anchor">#</a> 作用域&amp;闭包</h2> <h3 id="作用域"><a href="#作用域" class="header-anchor">#</a> 作用域</h3> <p>在我的理解中作用域就是变量访问的规则</p> <p>举个栗子</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">out</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 123</span>
<span class="token punctuation">}</span>
<span class="token function">outFun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a is not defined</span>
</code></pre></div><p>上面的例子可以体现作用域的意义，变量 a 在 out 函数中声明，所以在全局作用域下取值会报错</p> <blockquote><p>JavaScript 分为局部作用域和全局作用域（还有&quot;块级作用域&quot;，后面会说）</p></blockquote> <ul><li>变量在函数内声明为局部作用域，只能被当前作用域和内层的作用域访问；</li> <li>变量在全局声明则为全局作用域，能被任何地方访问；</li></ul> <p>js 中变量的访问规则：内层作用域可以访问外层作用域的变量，反之不行；
也就是说如果函数嵌套了函数，在最内部函数中访问某个变量时，会一层层往外访问声明的变量，层层访问就形成了作用域链；</p> <p>var 声明赋值的变量会在当前的作用域内预解析导致变量提升，当执行到赋值语句再赋值</p> <p>举个栗子</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">out</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 123</span>
<span class="token punctuation">}</span>
<span class="token function">outFun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>所有末定义直接赋值的变量自动声明为拥有全局作用域</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">out</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">outFun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 123</span>
</code></pre></div><p>原因也很简单，执行函数给 a 赋值时，会在作用域链上找定义 a 的作用域，一直访问到全局，也没有定义 a，于是 a 被定义在了 window 全局对象上，当我们访问 a 时就是访问的 window.a</p> <p>我们现在知道函数会创建一个的作用域,但是块语句(if 条件语句或 for 循环语句)不像函数，它们不会创建一个新的作用域。在块语句中定义的变量将保留在它们已经存在的作用域中。
这里就会引申出一个经典的面试题</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10</span>
</code></pre></div><p>这就是上面所说的,在块语句中定义的变量将保留在它们已经存在的作用域中,当我们调用 a[1]的时候 这个 i 其实就是最初在 for 中定义的 i,此时 for 循环执行完,i 已经是 10 了</p> <p>怎么解决这个问题呢 我们可以通过自调用函数传参数的方式创建 10 个函数,形成自己的作用域,就不会访问到最外层 for 循环定的的 i 变量了</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
</code></pre></div><p>说到这里,我们就可以引出&quot;块级作用域&quot;的概念了</p> <blockquote><p>块级作用域可通过在函数或者块语句(包括 if,for)用 es6 的 let 和 const 来声明形成</p></blockquote> <p>let const 将变量的作用域限制在当前代码块中。块级作用域有以下几个特点：</p> <ul><li>声明的变量不会提升到代码块顶部(变量提升)</li> <li>禁止重复声明相同的变量名</li></ul> <p>改造一下初始的 for 循环代码 将 var 换成 let 就能解决问题,每次循环 let 都会产生块级作用域,维护自身 i 的变量,防止污染</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
</code></pre></div><h3 id="作用域与执行上下文"><a href="#作用域与执行上下文" class="header-anchor">#</a> 作用域与执行上下文</h3> <p>许多人混淆作用域和执行上下文的概念，误认为它们是相同的概念，但其实并不是。
JavaScript 属于解释型语言，JavaScript 的执行分为：解释和执行两个阶段,这两个阶段所做的事并不一样：</p> <ol><li><p>解释阶段：</p> <ul><li>词法分析</li> <li>语法分析</li> <li>作用域规则确定</li></ul></li> <li><p>执行阶段：</p> <ul><li>创建执行上下文</li> <li>执行函数代码</li> <li>垃圾回收</li></ul></li></ol> <blockquote><p>JavaScript 解释阶段便会确定作用域规则，因此作用域在函数定义时就已经确定了，而不是在函数调用时确定，但是执行上下文是函数执行之前创建的。执行上下文最明显的就是 this 的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。</p></blockquote> <p>作用域和执行上下文之间最大的区别是：
执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变。
一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过,同一个作用域下，不同的调用会产生不同的执行上下文环境。</p> <h3 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h3> <p>对于闭包的定义有许多不同说法:</p> <ul><li><p>MDN:函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起构成闭包（closure）。也就是说，闭包可以让你从内部函数访问外部函数作用域。在 JavaScript 中，每当函数被创建，就会在函数生成时生成闭包。</p></li> <li><p>《javaScript 高级教程》中概念: 闭包是指有权访问另一个函数作用域中的变量的函数。</p></li> <li><p>任何一个函数都是闭包 (忘了在哪看的了)</p> <p>首先定义一个 out 的外层函数,out 中定义 a 为 1,再定义一个 inside 内部函数,去访问 a,运行 out,输出 inside 对象,上图</p> <p><img src="/assets/img/closure2.50c07d20.jpg" alt="闭包"></p> <p>发现 inside 对象中有[[Scopes]]数组,其中有两个对象</p> <ol><li>Closure: 包含了 out 函数中的活动对象</li> <li>Global: 全局对象</li></ol> <p>当我们把 inside 函数里的 console.log 注释,也就是不访问 out 中定义的 a 时,我们再来运行
<img src="/assets/img/closure1.0843f1e5.jpg" alt="闭包"></p> <p>发现[[Scopes]]数组中只剩一个 Global 对象了,也就是说只有内部访问了外层函数的变量,才会把外层函数的活动对象作为闭包放在[Scopes]]中,</p> <p>再给你们放上一张图<br> <img src="/assets/img/closure4.97f0def3.jpg" alt="闭包">
看了这个,不难猜到,虽然定义了 a,b,但是只有 a 被存在了闭包中,也就是说,只有被访问过的变量才会被保存起来的</p> <p>到这儿基本上都对闭包也有一定的理解了吧,对于一开始的闭包定义,我更倾向于 mdn 的说法
虽然从理论的角度将,js 中所有函数都是闭包,但是从应用的角度来说,只有当函数以返回值返回、或者当函数以参数形式使用、或者当函数中的变量在函数外被引用时,闭包才有意义。</p> <p>闭包很强大,用途之一是实现对象的私有数据。在 vue 中,对 data 数据做响应式时,就是把观察者对象存在了 get 的闭包函数中
但是滥用闭包,会导致内存无法被回收（参考浏览器的垃圾回收机制，后面有时间会补充进来的）,可以通过将引用的函数变量名复制为 null 手动清除;</p></li></ul> <h2 id="js-的单线程"><a href="#js-的单线程" class="header-anchor">#</a> JS 的单线程</h2> <p>作为浏览器的脚本语言，JavaScript 在设计之初就是单线程,为什么不是多线程提高效率呢？</p> <p>举个栗子：假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，那么就会浏览器根据那条线程判断呢？
为了避免复杂性，js 就被设计成了单线程（之后浏览器为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以并没有改变 JavaScript 引擎单线程的本质）。</p> <p>浏览器耗时任务开辟了另外的线程：</p> <ul><li>渲染引擎线程：顾名思义，该线程负责页面的渲染</li> <li>JS 引擎线程：负责 JS 的解析和执行</li> <li>定时触发器线程：处理定时事件，比如 setTimeout, setInterval</li> <li>事件触发线程：处理 DOM 事件（click）</li> <li>异步 http 请求线程：处理 http 请求</li></ul> <p>虽然 JavaScript 是单线程的，可是浏览器内部不是单线程的。一些 I/O 操作、定时器的计时和事件监听等都是由浏览器提供的其他线程来完成的。这些线程都会排列在主线程之外的任务队列，等待被执行，这就是异步的概念。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/basic-knowledge/es2015+.html">
        es2015
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.aedc5ffe.js" defer></script><script src="/assets/js/2.70898950.js" defer></script><script src="/assets/js/3.b6e4ebb5.js" defer></script>
  </body>
</html>
